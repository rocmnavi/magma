<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MAGMA: ggrqf: generalized RQ factorization of an M-by-N matrix A and a P-by-N matrix B</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="magma-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">MAGMA<span id="projectnumber">&#160;2.7.2</span>
   </div>
   <div id="projectbrief">Matrix Algebra for GPU and Multicore Architectures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__magma__ggrqf.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ggrqf: generalized RQ factorization of an M-by-N matrix A and a P-by-N matrix B<div class="ingroups"><a class="el" href="group__dense.html">Dense linear algebra</a> &raquo; <a class="el" href="group__group__orthogonal.html">Orthogonal/unitary factorizations</a> &raquo; <a class="el" href="group__group__rq.html">RQ factorization</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab27d1a0adac010b6130ac7bbd4e4185c"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__ggrqf.html#gab27d1a0adac010b6130ac7bbd4e4185c">magma_cggrqf</a> (magma_int_t m, magma_int_t p, magma_int_t n, magmaFloatComplex *A, magma_int_t lda, magmaFloatComplex *taua, magmaFloatComplex *B, magma_int_t ldb, magmaFloatComplex *taub, magmaFloatComplex *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr class="memdesc:gab27d1a0adac010b6130ac7bbd4e4185c"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGGRQF computes a generalized RQ factorization of an M-by-N matrix A <br  />
 and a P-by-N matrix B: <br  />
  <br /></td></tr>
<tr class="separator:gab27d1a0adac010b6130ac7bbd4e4185c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8417e610951ed8a7a652b2c505a1401f"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__ggrqf.html#ga8417e610951ed8a7a652b2c505a1401f">magma_dggrqf</a> (magma_int_t m, magma_int_t p, magma_int_t n, double *A, magma_int_t lda, double *taua, double *B, magma_int_t ldb, double *taub, double *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga8417e610951ed8a7a652b2c505a1401f"><td class="mdescLeft">&#160;</td><td class="mdescRight">DGGRQF computes a generalized RQ factorization of an M-by-N matrix A <br  />
 and a P-by-N matrix B: <br  />
  <br /></td></tr>
<tr class="separator:ga8417e610951ed8a7a652b2c505a1401f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga047233e40a72036820a95b2fb71afae7"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__ggrqf.html#ga047233e40a72036820a95b2fb71afae7">magma_sggrqf</a> (magma_int_t m, magma_int_t p, magma_int_t n, float *A, magma_int_t lda, float *taua, float *B, magma_int_t ldb, float *taub, float *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga047233e40a72036820a95b2fb71afae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGGRQF computes a generalized RQ factorization of an M-by-N matrix A <br  />
 and a P-by-N matrix B: <br  />
  <br /></td></tr>
<tr class="separator:ga047233e40a72036820a95b2fb71afae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b391dd97b5eb3e814ab180a90076f6d"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__ggrqf.html#ga6b391dd97b5eb3e814ab180a90076f6d">magma_zggrqf</a> (magma_int_t m, magma_int_t p, magma_int_t n, magmaDoubleComplex *A, magma_int_t lda, magmaDoubleComplex *taua, magmaDoubleComplex *B, magma_int_t ldb, magmaDoubleComplex *taub, magmaDoubleComplex *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga6b391dd97b5eb3e814ab180a90076f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZGGRQF computes a generalized RQ factorization of an M-by-N matrix A <br  />
 and a P-by-N matrix B: <br  />
  <br /></td></tr>
<tr class="separator:ga6b391dd97b5eb3e814ab180a90076f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab27d1a0adac010b6130ac7bbd4e4185c" name="gab27d1a0adac010b6130ac7bbd4e4185c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab27d1a0adac010b6130ac7bbd4e4185c">&#9670;&#160;</a></span>magma_cggrqf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cggrqf </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>taua</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>taub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CGGRQF computes a generalized RQ factorization of an M-by-N matrix A <br  />
 and a P-by-N matrix B: <br  />
 </p>
<pre class="fragment">        A = R*Q,        B = Z*T*Q,   
</pre><p> where Q is an N-by-N unitary matrix, Z is a P-by-P unitary <br  />
 matrix, and R and T assume one of the forms: <br  />
</p>
<p>if M &lt;= N, R = ( 0 R12 ) M, or if M &gt; N, R = ( R11 ) M-N, <br  />
 N-M M ( R21 ) N <br  />
 N <br  />
</p>
<p>where R12 or R21 is upper triangular, and <br  />
</p>
<p>if P &gt;= N, T = ( T11 ) N , or if P &lt; N, T = ( T11 T12 ) P, <br  />
 ( 0 ) P-N P N-P <br  />
 N <br  />
</p>
<p>where T11 is upper triangular. <br  />
</p>
<p>In particular, if B is square and nonsingular, the GRQ factorization <br  />
 of A and B implicitly gives the RQ factorization of A*inv(B): <br  />
 </p><pre class="fragment">         A*inv(B) = (R*inv(T))*Z'   
</pre><p> where inv(B) denotes the inverse of the matrix B, and Z' denotes the <br  />
 conjugate transpose of the matrix Z. <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER <br  />
 The number of rows of the matrix A. M &gt;= 0. <br  />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>INTEGER <br  />
 The number of rows of the matrix B. P &gt;= 0. <br  />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER <br  />
 The number of columns of the matrices A and B. N &gt;= 0. <br  />
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>COMPLEX array, dimension (LDA,N) <br  />
 On entry, the M-by-N matrix A. <br  />
 On exit, if M &lt;= N, the upper triangle of the subarray <br  />
 A(1:M,N-M+1:N) contains the M-by-M upper triangular matrix R; <br  />
 if M &gt; N, the elements on and above the (M-N)-th subdiagonal <br  />
 contain the M-by-N upper trapezoidal matrix R; the remaining <br  />
 elements, with the array TAUA, represent the unitary <br  />
 matrix Q as a product of elementary reflectors (see Further <br  />
 Details). <br  />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER <br  />
 The leading dimension of the array A. LDA &gt;= max(1,M). <br  />
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taua</td><td>COMPLEX array, dimension (min(M,N)) <br  />
 The scalar factors of the elementary reflectors which <br  />
 represent the unitary matrix Q (see Further Details). <br  />
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td>COMPLEX array, dimension (LDB,N) <br  />
 On entry, the P-by-N matrix B. <br  />
 On exit, the elements on and above the diagonal of the array <br  />
 contain the min(P,N)-by-N upper trapezoidal matrix T (T is <br  />
 upper triangular if P &gt;= N); the elements below the diagonal, <br  />
 with the array TAUB, represent the unitary matrix Z as a <br  />
 product of elementary reflectors (see Further Details). <br  />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>INTEGER <br  />
 The leading dimension of the array B. LDB &gt;= max(1,P). <br  />
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taub</td><td>COMPLEX array, dimension (min(P,N)) <br  />
 The scalar factors of the elementary reflectors which <br  />
 represent the unitary matrix Z (see Further Details). <br  />
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) COMPLEX array, dimension (LWORK) <br  />
 On exit, if INFO = 0, WORK(1) returns the optimal LWORK. <br  />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER <br  />
 The dimension of the array WORK. LWORK &gt;= max(1,N,M,P). <br  />
 For optimum performance LWORK &gt;= max(N,M,P)*NB, <br  />
 where NB is the optimal blocksize for the QR factorization of a P-by-N matrix. <br  />
 If LWORK = -1, then a workspace query is assumed; the routine <br  />
 only calculates the optimal size of the WORK array, returns <br  />
 this value as the first entry of the WORK array, and no error <br  />
 message related to LWORK is issued by XERBLA. <br  />
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER <br  />
<ul>
<li>= 0: successful exit <br  />
</li>
<li>&lt; 0: if INFO=-i, the i-th argument had an illegal value. <br  />
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md49"></a>
Further Details</h2>
<p>The matrix Q is represented as a product of elementary reflectors <br  />
</p>
<p>Q = H(1) H(2) . . . H(k), where k = min(m,n). <br  />
</p>
<p>Each H(i) has the form <br  />
</p>
<p>H(i) = I - taua * v * v' <br  />
</p>
<p>where taua is a complex scalar, and v is a complex vector with <br  />
 v(n-k+i+1:n) = 0 and v(n-k+i) = 1; v(1:n-k+i-1) is stored on exit in <br  />
 A(m-k+i,1:n-k+i-1), and taua in TAUA(i). <br  />
 To form Q explicitly, use LAPACK subroutine ZUNGRQ. <br  />
 To use Q to update another matrix, use LAPACK subroutine CUNMRQ. <br  />
</p>
<p>The matrix Z is represented as a product of elementary reflectors <br  />
</p>
<p>Z = H(1) H(2) . . . H(k), where k = min(p,n). <br  />
</p>
<p>Each H(i) has the form <br  />
</p>
<p>H(i) = I - taub * v * v' <br  />
</p>
<p>where taub is a complex scalar, and v is a complex vector with <br  />
 v(1:i-1) = 0 and v(i) = 1; v(i+1:p) is stored on exit in B(i+1:p,i), <br  />
 and taub in TAUB(i). <br  />
 To form Z explicitly, use LAPACK subroutine CUNGQR. <br  />
 To use Z to update another matrix, use LAPACK subroutine CUNMQR. <br  />
 </p>

</div>
</div>
<a id="ga8417e610951ed8a7a652b2c505a1401f" name="ga8417e610951ed8a7a652b2c505a1401f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8417e610951ed8a7a652b2c505a1401f">&#9670;&#160;</a></span>magma_dggrqf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dggrqf </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>taua</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>taub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DGGRQF computes a generalized RQ factorization of an M-by-N matrix A <br  />
 and a P-by-N matrix B: <br  />
 </p>
<pre class="fragment">        A = R*Q,        B = Z*T*Q,   
</pre><p> where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal <br  />
 matrix, and R and T assume one of the forms: <br  />
</p>
<p>if M &lt;= N, R = ( 0 R12 ) M, or if M &gt; N, R = ( R11 ) M-N, <br  />
 N-M M ( R21 ) N <br  />
 N <br  />
</p>
<p>where R12 or R21 is upper triangular, and <br  />
</p>
<p>if P &gt;= N, T = ( T11 ) N , or if P &lt; N, T = ( T11 T12 ) P, <br  />
 ( 0 ) P-N P N-P <br  />
 N <br  />
</p>
<p>where T11 is upper triangular. <br  />
</p>
<p>In particular, if B is square and nonsingular, the GRQ factorization <br  />
 of A and B implicitly gives the RQ factorization of A*inv(B): <br  />
 </p><pre class="fragment">         A*inv(B) = (R*inv(T))*Z'   
</pre><p> where inv(B) denotes the inverse of the matrix B, and Z' denotes the <br  />
 conjugate transpose of the matrix Z. <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER <br  />
 The number of rows of the matrix A. M &gt;= 0. <br  />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>INTEGER <br  />
 The number of rows of the matrix B. P &gt;= 0. <br  />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER <br  />
 The number of columns of the matrices A and B. N &gt;= 0. <br  />
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>DOUBLE PRECISION array, dimension (LDA,N) <br  />
 On entry, the M-by-N matrix A. <br  />
 On exit, if M &lt;= N, the upper triangle of the subarray <br  />
 A(1:M,N-M+1:N) contains the M-by-M upper triangular matrix R; <br  />
 if M &gt; N, the elements on and above the (M-N)-th subdiagonal <br  />
 contain the M-by-N upper trapezoidal matrix R; the remaining <br  />
 elements, with the array TAUA, represent the orthogonal <br  />
 matrix Q as a product of elementary reflectors (see Further <br  />
 Details). <br  />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER <br  />
 The leading dimension of the array A. LDA &gt;= max(1,M). <br  />
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taua</td><td>DOUBLE PRECISION array, dimension (min(M,N)) <br  />
 The scalar factors of the elementary reflectors which <br  />
 represent the orthogonal matrix Q (see Further Details). <br  />
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td>DOUBLE PRECISION array, dimension (LDB,N) <br  />
 On entry, the P-by-N matrix B. <br  />
 On exit, the elements on and above the diagonal of the array <br  />
 contain the min(P,N)-by-N upper trapezoidal matrix T (T is <br  />
 upper triangular if P &gt;= N); the elements below the diagonal, <br  />
 with the array TAUB, represent the orthogonal matrix Z as a <br  />
 product of elementary reflectors (see Further Details). <br  />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>INTEGER <br  />
 The leading dimension of the array B. LDB &gt;= max(1,P). <br  />
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taub</td><td>DOUBLE PRECISION array, dimension (min(P,N)) <br  />
 The scalar factors of the elementary reflectors which <br  />
 represent the orthogonal matrix Z (see Further Details). <br  />
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) DOUBLE PRECISION array, dimension (LWORK) <br  />
 On exit, if INFO = 0, WORK(1) returns the optimal LWORK. <br  />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER <br  />
 The dimension of the array WORK. LWORK &gt;= max(1,N,M,P). <br  />
 For optimum performance LWORK &gt;= max(N,M,P)*NB, <br  />
 where NB is the optimal blocksize for the QR factorization of a P-by-N matrix. <br  />
 If LWORK = -1, then a workspace query is assumed; the routine <br  />
 only calculates the optimal size of the WORK array, returns <br  />
 this value as the first entry of the WORK array, and no error <br  />
 message related to LWORK is issued by XERBLA. <br  />
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER <br  />
<ul>
<li>= 0: successful exit <br  />
</li>
<li>&lt; 0: if INFO=-i, the i-th argument had an illegal value. <br  />
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md119"></a>
Further Details</h2>
<p>The matrix Q is represented as a product of elementary reflectors <br  />
</p>
<p>Q = H(1) H(2) . . . H(k), where k = min(m,n). <br  />
</p>
<p>Each H(i) has the form <br  />
</p>
<p>H(i) = I - taua * v * v' <br  />
</p>
<p>where taua is a real scalar, and v is a real vector with <br  />
 v(n-k+i+1:n) = 0 and v(n-k+i) = 1; v(1:n-k+i-1) is stored on exit in <br  />
 A(m-k+i,1:n-k+i-1), and taua in TAUA(i). <br  />
 To form Q explicitly, use LAPACK subroutine ZUNGRQ. <br  />
 To use Q to update another matrix, use LAPACK subroutine DORMRQ. <br  />
</p>
<p>The matrix Z is represented as a product of elementary reflectors <br  />
</p>
<p>Z = H(1) H(2) . . . H(k), where k = min(p,n). <br  />
</p>
<p>Each H(i) has the form <br  />
</p>
<p>H(i) = I - taub * v * v' <br  />
</p>
<p>where taub is a real scalar, and v is a real vector with <br  />
 v(1:i-1) = 0 and v(i) = 1; v(i+1:p) is stored on exit in B(i+1:p,i), <br  />
 and taub in TAUB(i). <br  />
 To form Z explicitly, use LAPACK subroutine DORGQR. <br  />
 To use Z to update another matrix, use LAPACK subroutine DORMQR. <br  />
 </p>

</div>
</div>
<a id="ga047233e40a72036820a95b2fb71afae7" name="ga047233e40a72036820a95b2fb71afae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga047233e40a72036820a95b2fb71afae7">&#9670;&#160;</a></span>magma_sggrqf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sggrqf </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>taua</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>taub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SGGRQF computes a generalized RQ factorization of an M-by-N matrix A <br  />
 and a P-by-N matrix B: <br  />
 </p>
<pre class="fragment">        A = R*Q,        B = Z*T*Q,   
</pre><p> where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal <br  />
 matrix, and R and T assume one of the forms: <br  />
</p>
<p>if M &lt;= N, R = ( 0 R12 ) M, or if M &gt; N, R = ( R11 ) M-N, <br  />
 N-M M ( R21 ) N <br  />
 N <br  />
</p>
<p>where R12 or R21 is upper triangular, and <br  />
</p>
<p>if P &gt;= N, T = ( T11 ) N , or if P &lt; N, T = ( T11 T12 ) P, <br  />
 ( 0 ) P-N P N-P <br  />
 N <br  />
</p>
<p>where T11 is upper triangular. <br  />
</p>
<p>In particular, if B is square and nonsingular, the GRQ factorization <br  />
 of A and B implicitly gives the RQ factorization of A*inv(B): <br  />
 </p><pre class="fragment">         A*inv(B) = (R*inv(T))*Z'   
</pre><p> where inv(B) denotes the inverse of the matrix B, and Z' denotes the <br  />
 conjugate transpose of the matrix Z. <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER <br  />
 The number of rows of the matrix A. M &gt;= 0. <br  />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>INTEGER <br  />
 The number of rows of the matrix B. P &gt;= 0. <br  />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER <br  />
 The number of columns of the matrices A and B. N &gt;= 0. <br  />
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>REAL array, dimension (LDA,N) <br  />
 On entry, the M-by-N matrix A. <br  />
 On exit, if M &lt;= N, the upper triangle of the subarray <br  />
 A(1:M,N-M+1:N) contains the M-by-M upper triangular matrix R; <br  />
 if M &gt; N, the elements on and above the (M-N)-th subdiagonal <br  />
 contain the M-by-N upper trapezoidal matrix R; the remaining <br  />
 elements, with the array TAUA, represent the orthogonal <br  />
 matrix Q as a product of elementary reflectors (see Further <br  />
 Details). <br  />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER <br  />
 The leading dimension of the array A. LDA &gt;= max(1,M). <br  />
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taua</td><td>REAL array, dimension (min(M,N)) <br  />
 The scalar factors of the elementary reflectors which <br  />
 represent the orthogonal matrix Q (see Further Details). <br  />
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td>REAL array, dimension (LDB,N) <br  />
 On entry, the P-by-N matrix B. <br  />
 On exit, the elements on and above the diagonal of the array <br  />
 contain the min(P,N)-by-N upper trapezoidal matrix T (T is <br  />
 upper triangular if P &gt;= N); the elements below the diagonal, <br  />
 with the array TAUB, represent the orthogonal matrix Z as a <br  />
 product of elementary reflectors (see Further Details). <br  />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>INTEGER <br  />
 The leading dimension of the array B. LDB &gt;= max(1,P). <br  />
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taub</td><td>REAL array, dimension (min(P,N)) <br  />
 The scalar factors of the elementary reflectors which <br  />
 represent the orthogonal matrix Z (see Further Details). <br  />
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) REAL array, dimension (LWORK) <br  />
 On exit, if INFO = 0, WORK(1) returns the optimal LWORK. <br  />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER <br  />
 The dimension of the array WORK. LWORK &gt;= max(1,N,M,P). <br  />
 For optimum performance LWORK &gt;= max(N,M,P)*NB, <br  />
 where NB is the optimal blocksize for the QR factorization of a P-by-N matrix. <br  />
 If LWORK = -1, then a workspace query is assumed; the routine <br  />
 only calculates the optimal size of the WORK array, returns <br  />
 this value as the first entry of the WORK array, and no error <br  />
 message related to LWORK is issued by XERBLA. <br  />
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER <br  />
<ul>
<li>= 0: successful exit <br  />
</li>
<li>&lt; 0: if INFO=-i, the i-th argument had an illegal value. <br  />
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md191"></a>
Further Details</h2>
<p>The matrix Q is represented as a product of elementary reflectors <br  />
</p>
<p>Q = H(1) H(2) . . . H(k), where k = min(m,n). <br  />
</p>
<p>Each H(i) has the form <br  />
</p>
<p>H(i) = I - taua * v * v' <br  />
</p>
<p>where taua is a real scalar, and v is a real vector with <br  />
 v(n-k+i+1:n) = 0 and v(n-k+i) = 1; v(1:n-k+i-1) is stored on exit in <br  />
 A(m-k+i,1:n-k+i-1), and taua in TAUA(i). <br  />
 To form Q explicitly, use LAPACK subroutine ZUNGRQ. <br  />
 To use Q to update another matrix, use LAPACK subroutine SORMRQ. <br  />
</p>
<p>The matrix Z is represented as a product of elementary reflectors <br  />
</p>
<p>Z = H(1) H(2) . . . H(k), where k = min(p,n). <br  />
</p>
<p>Each H(i) has the form <br  />
</p>
<p>H(i) = I - taub * v * v' <br  />
</p>
<p>where taub is a real scalar, and v is a real vector with <br  />
 v(1:i-1) = 0 and v(i) = 1; v(i+1:p) is stored on exit in B(i+1:p,i), <br  />
 and taub in TAUB(i). <br  />
 To form Z explicitly, use LAPACK subroutine SORGQR. <br  />
 To use Z to update another matrix, use LAPACK subroutine SORMQR. <br  />
 </p>

</div>
</div>
<a id="ga6b391dd97b5eb3e814ab180a90076f6d" name="ga6b391dd97b5eb3e814ab180a90076f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b391dd97b5eb3e814ab180a90076f6d">&#9670;&#160;</a></span>magma_zggrqf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zggrqf </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>taua</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>taub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZGGRQF computes a generalized RQ factorization of an M-by-N matrix A <br  />
 and a P-by-N matrix B: <br  />
 </p>
<pre class="fragment">        A = R*Q,        B = Z*T*Q,   
</pre><p> where Q is an N-by-N unitary matrix, Z is a P-by-P unitary <br  />
 matrix, and R and T assume one of the forms: <br  />
</p>
<p>if M &lt;= N, R = ( 0 R12 ) M, or if M &gt; N, R = ( R11 ) M-N, <br  />
 N-M M ( R21 ) N <br  />
 N <br  />
</p>
<p>where R12 or R21 is upper triangular, and <br  />
</p>
<p>if P &gt;= N, T = ( T11 ) N , or if P &lt; N, T = ( T11 T12 ) P, <br  />
 ( 0 ) P-N P N-P <br  />
 N <br  />
</p>
<p>where T11 is upper triangular. <br  />
</p>
<p>In particular, if B is square and nonsingular, the GRQ factorization <br  />
 of A and B implicitly gives the RQ factorization of A*inv(B): <br  />
 </p><pre class="fragment">         A*inv(B) = (R*inv(T))*Z'   
</pre><p> where inv(B) denotes the inverse of the matrix B, and Z' denotes the <br  />
 conjugate transpose of the matrix Z. <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER <br  />
 The number of rows of the matrix A. M &gt;= 0. <br  />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>INTEGER <br  />
 The number of rows of the matrix B. P &gt;= 0. <br  />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER <br  />
 The number of columns of the matrices A and B. N &gt;= 0. <br  />
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>COMPLEX_16 array, dimension (LDA,N) <br  />
 On entry, the M-by-N matrix A. <br  />
 On exit, if M &lt;= N, the upper triangle of the subarray <br  />
 A(1:M,N-M+1:N) contains the M-by-M upper triangular matrix R; <br  />
 if M &gt; N, the elements on and above the (M-N)-th subdiagonal <br  />
 contain the M-by-N upper trapezoidal matrix R; the remaining <br  />
 elements, with the array TAUA, represent the unitary <br  />
 matrix Q as a product of elementary reflectors (see Further <br  />
 Details). <br  />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER <br  />
 The leading dimension of the array A. LDA &gt;= max(1,M). <br  />
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taua</td><td>COMPLEX_16 array, dimension (min(M,N)) <br  />
 The scalar factors of the elementary reflectors which <br  />
 represent the unitary matrix Q (see Further Details). <br  />
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td>COMPLEX_16 array, dimension (LDB,N) <br  />
 On entry, the P-by-N matrix B. <br  />
 On exit, the elements on and above the diagonal of the array <br  />
 contain the min(P,N)-by-N upper trapezoidal matrix T (T is <br  />
 upper triangular if P &gt;= N); the elements below the diagonal, <br  />
 with the array TAUB, represent the unitary matrix Z as a <br  />
 product of elementary reflectors (see Further Details). <br  />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>INTEGER <br  />
 The leading dimension of the array B. LDB &gt;= max(1,P). <br  />
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taub</td><td>COMPLEX_16 array, dimension (min(P,N)) <br  />
 The scalar factors of the elementary reflectors which <br  />
 represent the unitary matrix Z (see Further Details). <br  />
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) COMPLEX_16 array, dimension (LWORK) <br  />
 On exit, if INFO = 0, WORK(1) returns the optimal LWORK. <br  />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER <br  />
 The dimension of the array WORK. LWORK &gt;= max(1,N,M,P). <br  />
 For optimum performance LWORK &gt;= max(N,M,P)*NB, <br  />
 where NB is the optimal blocksize for the QR factorization of a P-by-N matrix. <br  />
 If LWORK = -1, then a workspace query is assumed; the routine <br  />
 only calculates the optimal size of the WORK array, returns <br  />
 this value as the first entry of the WORK array, and no error <br  />
 message related to LWORK is issued by XERBLA. <br  />
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER <br  />
<ul>
<li>= 0: successful exit <br  />
</li>
<li>&lt; 0: if INFO=-i, the i-th argument had an illegal value. <br  />
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md263"></a>
Further Details</h2>
<p>The matrix Q is represented as a product of elementary reflectors <br  />
</p>
<p>Q = H(1) H(2) . . . H(k), where k = min(m,n). <br  />
</p>
<p>Each H(i) has the form <br  />
</p>
<p>H(i) = I - taua * v * v' <br  />
</p>
<p>where taua is a complex scalar, and v is a complex vector with <br  />
 v(n-k+i+1:n) = 0 and v(n-k+i) = 1; v(1:n-k+i-1) is stored on exit in <br  />
 A(m-k+i,1:n-k+i-1), and taua in TAUA(i). <br  />
 To form Q explicitly, use LAPACK subroutine ZUNGRQ. <br  />
 To use Q to update another matrix, use LAPACK subroutine ZUNMRQ. <br  />
</p>
<p>The matrix Z is represented as a product of elementary reflectors <br  />
</p>
<p>Z = H(1) H(2) . . . H(k), where k = min(p,n). <br  />
</p>
<p>Each H(i) has the form <br  />
</p>
<p>H(i) = I - taub * v * v' <br  />
</p>
<p>where taub is a complex scalar, and v is a complex vector with <br  />
 v(1:i-1) = 0 and v(i) = 1; v(i+1:p) is stored on exit in B(i+1:p,i), <br  />
 and taub in TAUB(i). <br  />
 To form Z explicitly, use LAPACK subroutine ZUNGQR. <br  />
 To use Z to update another matrix, use LAPACK subroutine ZUNMQR. <br  />
 </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
